#!/usr/bin/env python
# -*- coding: utf-8 -*-

#==============================================================================
# ラジコン・カーに追加した左右のロータリー・エンコーダーの制御プログラム
#                                           RotaryEncoder.py Ver.1.2
#                                           fan4fun2rc 20 Feb. 2022
#------------------------------------------------------------------------------
#　ラジコン・カーの左右のモーターの速度制御のために追加したロータリー・エンコーダー
#　を使用して入力したパルス数からタイヤの回転速度と計測すると共に、位置情報を
#  予測する
#
#【仕様】
#　・使用するロータリー・エンコーダー(RE)はアルプス社のEC10Eシリーズ
#　・左のREはA相がGPIO-20、B相がGPIO-21で取付が前進時にCW方向
#　・右のREはA相がGPIO-7、B相がGPIO-8で取付が前進時にCCW方向
#　・タイヤには1回転36歯車のギヤを付け、REには1回転22歯車のギヤで受けている
#　・REは1回転12パルス出力し24のクリックがある、AB両相の両エッジで4倍して48パルス
#　・つまり、タイヤ1回転で36/22x48=78.545454パルス出力される
#　・そこで、1パルス当たり360/78.545454=4.58333度となる
#　・タイヤの直径は78mmなので1回転で245.044mm走行する
#　・このプログラムでは、1パルス当たり245.044/360x4.58333=3.119776mm走行とする
#
#【関数概要】
#　１．ロータリー・エンコーダー割り込み処理関数：rotary_enc(引数)
#　２．初期化関数：init()
#　３．ロータリー・エンコーダーのカウント数を返却する関数：get_pls_cnt()
#　４．メイン処理関数：main()
#
#【リビジョン・ヒストリ】
#　・V1.0-2022/02/18:コーディング開始
#　・V1.1-2022/02/20:1秒毎に左右のパルス数を表示する
#　・V1.2-2022/02/20:1秒毎に左右の秒速度を表示する
#==============================================================================

#------------------------------------------------------------------------------
#　インポートするライブラリの宣言
#------------------------------------------------------------------------------
import RPi.GPIO as GPIO
import time
import copy

#------------------------------------------------------------------------------
# ロータリー・エンコーダーの入力ポートをBCM番号で定義する
#------------------------------------------------------------------------------
LEA = 20    # 左RE-AのGPIOポート番号
LEB = 21    # 左RE-BのGPIOポート番号
REA = 8     # 右RE-AのGPIOポート番号、右側は前進でCCW回転なのでAB相を逆に設定する
REB = 7     # 右RE-BのGPIOポート番号
#------------------------------------------------------------------------------
# モジュールで使用する定数を定義する
#------------------------------------------------------------------------------
MMP = 3.119776  # 1パルスで進む距離

#==============================================================================
# １．ロータリー・エンコーダー割り込み処理関数：rotary_enc(引数)
#   ＜引数：割り込みを発生させたREのポート番号＞
#------------------------------------------------------------------------------
#　・AがLからHへの変化の時：BがLならカウントを＋１
#　                       ：BがHならカウントを－１
#　・AがHからLへの変化の時：BがHならカウントを＋１
#　                       ：BがLならカウントを－１
#　・BがLからHへの変化の時：AがHならカウントを＋１
#　                       ：AがLならカウントを－１
#　・BがHからLへの変化の時：AがLならカウントを＋１
#　                       ：AがHならカウントを－１
#==============================================================================
def rotary_enc(re):
    ix = rotary_enc.port.index(re)      # 変化したポート番号からインデックスに変換
    cre = GPIO.input(re)                # 現在のRE状態を取り込む
    if rotary_enc.state[ix] != cre:     # 一つ前の状態と不一致なら変化あり
        rotary_enc.state[ix] = cre      # 次の処理のために一つ前の状態として保存
        #
        # LEAがLからHに変化
        #
        if ix == 0 and cre == GPIO.HIGH:
            if rotary_enc.state[1] == GPIO.LOW:     # LEBがLならインクリメント
                rotary_enc.count[0] += 1
            else:                                   # LEBがHならデクリメント
                rotary_enc.count[0] -= 1
        #
        # LEAがHからLに変化
        #
        elif ix == 0 and cre == GPIO.LOW:
            if rotary_enc.state[1] == GPIO.HIGH:    # LEBがHならインクリメント
                rotary_enc.count[0] += 1
            else:                                   # LEBがLならデクリメント
                rotary_enc.count[0] -= 1
        #
        # LEBがLからHに変化
        #
        elif ix == 1 and cre == GPIO.HIGH:
            if rotary_enc.state[0] == GPIO.HIGH:    # LEAがHならインクリメント
                rotary_enc.count[0] += 1
            else:                                   # LEAがLならデクリメント
                rotary_enc.count[0] -= 1
        #
        # LEBがHからLに変化
        #
        elif ix == 1 and cre == GPIO.LOW:
            if rotary_enc.state[0] == GPIO.LOW:     # LEAがLならインクリメント
                rotary_enc.count[0] += 1
            else:                                   # LEAがHならデクリメント
                rotary_enc.count[0] -= 1
        #
        # REAがLからHに変化
        #
        elif ix == 2 and cre == GPIO.HIGH:
            if rotary_enc.state[3] == GPIO.LOW:     # REBがLならインクリメント
                rotary_enc.count[1] += 1
            else:                                   # REBがHならデクリメント
                rotary_enc.count[1] -= 1
        #
        # REAがHからLに変化
        #
        elif ix == 2 and cre == GPIO.LOW:
            if rotary_enc.state[3] == GPIO.HIGH:    # REBがHならインクリメント
                rotary_enc.count[1] += 1
            else:                                   # REBがLならデクリメント
                rotary_enc.count[1] -= 1
        #
        # REBがLからHに変化
        #
        elif ix == 3 and cre == GPIO.HIGH:
            if rotary_enc.state[2] == GPIO.HIGH:    # REAがHならインクリメント
                rotary_enc.count[1] += 1
            else:                                   # REAがLならデクリメント
                rotary_enc.count[1] -= 1
        #
        # REBがHからLに変化
        #
        elif ix == 3 and cre == GPIO.LOW:
            if rotary_enc.state[2] == GPIO.LOW:     # REAがLならインクリメント
                rotary_enc.count[1] += 1
            else:                                   # REAがHならデクリメント
                rotary_enc.count[1] -= 1


#==============================================================================
# ２．初期化関数：init()
#------------------------------------------------------------------------------
#　・GPIOの指定にBCM番号を使用する
#　・REにつないだGPIOポートを入力に設定し、プルアップをオンする
#　・SWポートを立ち下がりと立ち下がりの両エッジ割り込み処理に設定し、
#　　処理関数はrotary_enc()で再割り込み禁止設定はしない
#　・rotary_enc()関数で使用するスタティック変数を定義し初期化する
#==============================================================================
def init():
    GPIO.setmode(GPIO.BCM)      # GPIOの指定にBCM番号を使用する
    #
    # rotary_enc()関数で使用するスタティック変数を定義し初期化する
    #
    rotary_enc.port  = [LEA,LEB,REA,REB]    # ポート番号とリストのインデックスをリンクする
    rotary_enc.state = [2,2,2,2]            # 一つ前のRE状態を保持するリストを作成
    rotary_enc.count = [0,0]                # 左右のパルスカウント値を保持するリストを作成
    #
    # REにつないだGPIOポートを入力に設定し、プルアップをオンする
    #
    GPIO.setup(LEA, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(LEB, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(REA, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(REB, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    #
    # SWポートを立ち下がりと立ち下がりの両エッジ割り込み処理に設定し、
    # 処理関数はrotary_enc()で再割り込み禁止設定はしない
    #
    GPIO.add_event_detect(LEA, GPIO.BOTH, callback=rotary_enc)
    GPIO.add_event_detect(LEB, GPIO.BOTH, callback=rotary_enc)
    GPIO.add_event_detect(REA, GPIO.BOTH, callback=rotary_enc)
    GPIO.add_event_detect(REB, GPIO.BOTH, callback=rotary_enc)


#==============================================================================
# ３．ロータリー・エンコーダーのカウント数を返却する関数：get_pls_cnt()
#------------------------------------------------------------------------------
#　・モジュール変数を隠ぺいするゲッター関数
#==============================================================================
def get_pls_cnt():
    l = rotary_enc.count[0]
    r = rotary_enc.count[1]
    rotary_enc.count = [0,0]    # カウンターを初期化
    return [l, r]               # カウント値をリターン


#==============================================================================
# ４．メイン処理関数：main()
#------------------------------------------------------------------------------
#　・init()をコールし、GPIOの設定やモジュール変数の定義と初期化を行う
#　・無限メインループ：終了条件に(^C)をキャッチできるようにする
#　  ・100ms毎のパルス数から過去10回分の平均速度(mm/sec)を求める
#　  ・1秒に一回、秒速を表示する
#　・終了処理
#==============================================================================
def main():
    l = [0] * 10    # 左の10回分のパルス数をメモルリスト
    r = [0] * 10    # 右の10回分のパルス数をメモルリスト
    Lsum = 0        # 左の10回分のパルス数を足した値
    Rsum = 0        # 右の10回分のパルス数を足した値
    i = 0           # 10回カウンタ
    #
    # GPIOの設定やモジュール変数の定義と初期化を行う
    #
    init()
    print("[%s]:アプリケーションを開始します。" % time.ctime())
    #
    # 無限メインループ：終了条件に(^C)をキャッチできるようにする
    #
    try:
        while True:
            time.sleep(0.1)         # 100ms毎にパルス増分を取り込み処理する
            ccnt = get_pls_cnt()
            #
            # 100ms毎のパルス数から過去10回分の平均速度(mm/sec)を求める
            #
            Lsum = Lsum - l[i] + ccnt[0]    # 10回前の値を削除して今回分を足す
            Rsum = Rsum - r[i] + ccnt[1]
            l[i] = ccnt[0]
            r[i] = ccnt[1]
            i += 1
            i %= 10
            #
            # 1秒に一回、秒速を表示する
            #
            if i == 0:
                lsp = Lsum * MMP    # MMPは1パルス当たりの走行距離(mm)
                rsp = Rsum * MMP
                print("[%s]:左速度:%4dmm/s, 右速度:%4dmm/s" % (time.ctime(), lsp, rsp))

    #
    # 終了条件の(^C)をキャッチする
    #
    except KeyboardInterrupt:
        pass

    #
    # 終了処理
    #
    print("[%s]:アプリケーションを終了します。" % time.ctime())
    GPIO.cleanup()


#------------------------------------------------------------------------------
# このファイルから起動時のみ実行する
#------------------------------------------------------------------------------
if __name__ == "__main__":
    main()
